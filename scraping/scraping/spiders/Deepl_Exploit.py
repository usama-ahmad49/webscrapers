# PYTHON DEEPL EXPLOIT

# Before using this DeepL translation script, you will need to install the following libraries.

# 1) Selenium Documentation - Used to automate browser actions:
# https://selenium-python.readthedocs.io/installation.html#detailed-instructions-for-windows-users

    # a) Gecko driver download, which is needed for Selenium: https://github.com/mozilla/geckodriver/releases

    # b) How to put Gecko driver into path: https://stackoverflow.com/questions/40208051/selenium-using-python-geckodriver-executable-needs-to-be-in-path

# 2) Python Docx Documentation - Used to scrape Microsoft Word (.docx files)
# https://python-docx.readthedocs.io/eQu1ckS1lver!n/latest/index.html#user-guide

# 3) Pyperclip Documentation - Used to copy information from the Clipboard into variables:
# https://pypi.org/project/pyperclip/
import time
import unidecode
import configparser as configparser
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.common.exceptions import NoSuchElementException
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.firefox.options import Options
from selenium.webdriver.firefox.firefox_binary import FirefoxBinary
from selenium.webdriver.common.keys import Keys
import os
import pyperclip


#+++++++++++++++++++++++++++++ USER INPUT ++++++++++++++++++++++++++++++++

# Give the variable the name of your input document and put the input document into the directory of this Python file
# input_file_name = "input.docx"
# input_file_name = "Input - Copy.docx"

# Choose between EN (English), DE (German), FR (French), ES (Spanish), IT (Italian), NL (Dutch), PL (Polish),zh (chinese)
from_language = "zh"
to_language = "en"

#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


paragraphs = []
inputfileread = 'Input.ini'
inputfileconvertedread = 'Input_converted.ini'
outputEncoding = ''
#encode file to utf-8
with open(inputfileread, 'rb') as source_file:
  with open(inputfileconvertedread, 'w+b') as dest_file:
    contents = source_file.read()
    try:
        dest_file.write(contents.decode('Big5').encode('utf-8'))
        outputEncoding = 'Big5'
    except:
        dest_file.write(contents.decode('GB18030').encode('utf-8'))
        outputEncoding = 'GB18030'
# inputfile = open(inputfileread, 'r', encoding='Big5')
inputfile = open(inputfileconvertedread, 'r', encoding='utf-8')
linesToTranslate = inputfile.read()
if linesToTranslate.split('|\n').__len__()>1:
    linesToTranslate = linesToTranslate.split('|\n')
else:
    linesToTranslate = linesToTranslate.split('\n')
# driver = webdriver.Firefox()
options = Options()
options.binary_location = r'C:\Program Files\Mozilla Firefox\firefox.exe'
driver = webdriver.Firefox(executable_path=r'C:\Windows\geckodriver.exe', options=options)
# We navigate to the DeepL website with geckobrowser and change the translator to our desired settings
driver.get("https://www.deepl.com/translator#" + from_language + "/" + to_language + "/" + "%0A")

# Check if we got to the DeepL website
assert "DeepL" in driver.title # Check whether it actually is on the DeepL website



# This is where the translation of the document's paragraphs is performed in DeepL
# We first define a list called "translation" that will store all our translated paragraphs. Next, we iterate through all the paragraphs in our paragraph list and check whether they have letters in them. If they dont, they are not translated and aren't added to the translation list.
# If the paragraphs do have letters in them, we find the input field on the DeepL website, click the box to register an input, and input our paragraph. We try to wait for the "busy indicator" to dissapear, which signals that the translation is complete, and click the target text box, where our translated text is stored. We copy this text and save it in a variable called "trans". Finally, we delete the input field's values and start over.
translation = []
for paragraph in linesToTranslate:
    # lettercount = lettercheck(paragraph
    if len(paragraph) == 0:
        trans = '\n'
        translation.append(trans)
        continue
    lettercount = 1
    if lettercount == 0:
        continue

    else:
        # Find input field an paste paragraph
        elem = driver.find_element_by_xpath("//textarea[@class='lmt__textarea lmt__source_textarea lmt__textarea_base_style']")
        elem.click()
        elem.send_keys(paragraph+'|')

        try:
            elem = WebDriverWait(driver,20).until(EC.invisibility_of_element_located((By.CLASS_NAME, "loadingIndicator_module_loadingIndicator__e5ced9d0")))
            # time.sleep(0.5)
            elem = driver.find_element_by_xpath("/html/body/div[3]/main/div[4]/div[3]/section[2]/div[3]/div[1]/textarea")
            elem.click()
            elem.send_keys(Keys.CONTROL, "a")
            elem.send_keys(Keys.CONTROL, "c")
            while True:
                trans = pyperclip.paste()
                if '[...]'not in trans or len(trans) > 4:
                    if 'Translated with www.DeepL.com/Translator (free version)' not in trans:
                        trans = trans.replace('\r','')
                        translation.append(trans)
                    else:
                        trans = trans.replace('\nTranslated with www.DeepL.com/Translator (free version)','')
                        trans = trans.replace('\rTranslated with www.DeepL.com/Translator (free version)','')
                        trans = trans.replace('\r\nTranslated with www.DeepL.com/Translator (free version)','')
                        trans = trans.replace('\r', '')
                        translation.append(trans)
                    break
                else:
                    time.sleep(0.5)


            #  Find input field and delete former input
            try:
                elem = driver.find_element_by_xpath('//*[@id="panelTranslateText"]/div[3]/section[1]/div[3]/div[2]/textarea')
                elem.click()
                elem.send_keys(Keys.CONTROL, "a")
                elem.send_keys(Keys.BACKSPACE)
            except:
                elem = driver.find_element_by_xpath("//textarea[@class='lmt__textarea lmt__source_textarea lmt__textarea_base_style lmt__textarea--inactive']")
                elem.click()
                elem.send_keys(Keys.CONTROL, "a")
                elem.send_keys(Keys.BACKSPACE)

        # Catch the exception case tha no more input is posted into the input field and the output field is unavailable. This should only happen when the document is over.
        except NoSuchElementException:
            continue
driver.quit()

out_file = open('output_preconverted.ini', 'w', encoding = 'utf-8')
print("...And created new one. \n")
total = translation.__len__()
i=1
for item in translation:
    item = unidecode.unidecode(item)
    if i==1:
        item = item.replace('\r','').replace('\n','')
    if i ==total:
        item = item.replace('||','|')
    i+=1
    out_file.write(item+'\n')
    out_file.flush()

with open('output_preconverted.ini', 'rb') as source_file:
  with open('output.ini', 'w+b') as dest_file:
    contents = source_file.read()
    dest_file.write(contents.decode('utf-8').encode('Big5'))
inputfile.close()
out_file.close()
os.remove('Input_converted.ini')
os.remove('output_preconverted.ini')
# FUTURE IMPROVEMENTS:
"""
- Tables are currently not formatted correctly and are instead inserted into the output document as seperate paragraphs. This is pretty annoying and should be fixed in the next version.

- No paragraph formatting is kept after translation. This can be fixed by copying the "style" attribute of the individual runs in a paragraph. To do so, we could try to split a paragraph into a run for each word and then copying the styling of each run.

- No pictures are transferred into the output word document
"""


